<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NexusGuard DeFi Protocol - Project Dashboard</title>
    
    <!-- External Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    
    <style>
        :root {
            --primary-color: #2d3436;
            --secondary-color: #0984e3;
            --success-color: #00b894;
            --warning-color: #fdcb6e;
            --danger-color: #d63031;
            --light-bg: #f5f6fa;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--light-bg);
        }

        .dashboard-container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }

        .nav-tabs {
            margin-bottom: 20px;
            border-bottom: 2px solid var(--secondary-color);
        }

        .nav-tabs .nav-link {
            color: var(--primary-color);
            border: none;
            padding: 10px 20px;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }

        .nav-tabs .nav-link.active {
            background-color: var(--secondary-color);
            color: white;
        }

        .section-title {
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .card {
            border: none;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .module-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid var(--secondary-color);
        }

        .component-list {
            list-style: none;
            padding-left: 0;
        }

        .component-item {
            padding: 8px;
            margin: 4px 0;
            background: var(--light-bg);
            border-radius: 4px;
            font-size: 0.9em;
        }

        .sprint-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .sprint-column {
            background: white;
            padding: 15px;
            border-radius: 8px;
            min-height: 500px;
        }

        .task-card {
            background: var(--light-bg);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .dependency-chart {
            width: 100%;
            height: 800px;
            background: white;
            padding: 20px;
            border-radius: 10px;
        }

        .metrics-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .progress {
            height: 8px;
            margin-top: 10px;
        }

        /* Custom styles for specific components */
        .security-component {
            border-left-color: var(--danger-color);
        }

        .analytics-component {
            border-left-color: var(--success-color);
        }

        .visualization-component {
            border-left-color: var(--warning-color);
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Navigation Tabs -->
        <ul class="nav nav-tabs" id="projectTabs" role="tablist">
            <li class="nav-item">
                <a class="nav-link active" data-bs-toggle="tab" href="#overview">Project Overview</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-bs-toggle="tab" href="#architecture">Architecture</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-bs-toggle="tab" href="#sprints">Sprint Board</a>
            </li>
            <li class="nav-item">
                <a class="nav-link" data-bs-toggle="tab" href="#components">Components</a>
            </li>
        </ul>

        <!-- Tab Content -->
        <div class="tab-content">
            <!-- Overview Tab -->
            <div class="tab-pane fade show active" id="overview">
                <h1 class="section-title">
                    <i class="fas fa-shield-alt"></i> 
                    NexusGuard DeFi Protocol Overview
                </h1>

                <!-- Metrics Overview -->
                <div class="metrics-panel">
                    <!-- Project Metrics -->
                </div>

                <!-- Quick Status -->
                <div class="row">
                    <!-- Status Cards -->
                </div>
            </div>

            <!-- Architecture Tab -->
            <div class="tab-pane fade" id="architecture">
                <h2 class="section-title">System Architecture</h2>
                <div class="dependency-chart">
                    <div class="mermaid">
                        <!-- Mermaid Diagram Here -->
                    </div>
                </div>
            </div>

            <!-- Sprint Board Tab -->
            <div class="tab-pane fade" id="sprints">
                <h2 class="section-title">Active Sprint Board</h2>
                <div class="sprint-board">
                    <!-- Sprint Columns -->
                </div>
            </div>

            <!-- Components Tab -->
            <div class="tab-pane fade" id="components">
                <h2 class="section-title">Project Components</h2>
                <div class="row">
                    <!-- Component Cards -->
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Initialize Mermaid
        mermaid.initialize({
            theme: 'default',
            securityLevel: 'loose',
            flowchart: {
                curve: 'basis'
            }
        });

        // Component data structure
        const components = {
            // Component definitions will go here
        };

        const componentStructure = {
    core: {
        name: 'Core Protocol',
        components: {
            protocol: {
                name: 'NexusGuardDeFiProtocolV1',
                status: 'in-progress',
                priority: 'critical',
                dependencies: ['SecurityManager', 'Registry'],
                tasks: [
                    { id: 'CORE-1', name: 'Initialize core protocol', status: 'in-progress' },
                    { id: 'CORE-2', name: 'Setup component registration', status: 'pending' },
                ]
            },
            registry: {
                name: 'NexusGuardRegistry',
                status: 'active',
                priority: 'high',
                components: ['BaseRegistry', 'ComponentRegistry']
            },
            bridge: {
                name: 'Cross-Chain Components',
                components: ['CrossChainManager', 'NexusGuardBridge']
            }
        }
    },
    security: {
        name: 'Security Components',
        components: {
            manager: {
                name: 'SecurityManager',
                status: 'in-progress',
                priority: 'critical',
                subcomponents: [
                    'AccessControl',
                    'BlocklistManager',
                    'EmergencySystem',
                    'FraudDetection',
                    'IntrusionDetection',
                    'RateLimiter',
                    'SecurityAudit',
                    'SecurityBenchmark'
                ]
            },
            validator: {
                name: 'Security Validation',
                components: [
                    'SecurityValidator',
                    'SecurityChecks',
                    'SecurityMetrics',
                    'SecurityPatterns'
                ]
            },
            sync: {
                name: 'State Synchronization',
                components: [
                    'ValidatorStateSynchronizer',
                    'NexusGuardStateSynchronizer'
                ]
            }
        }
    },
    analytics: {
        name: 'Analytics System',
        components: {
            engine: {
                name: 'AnalyticsEngine',
                subcomponents: [
                    'AnalyticsStorage',
                    'AnalyticsValidator',
                    'DataAggregator',
                    'ReportGenerator'
                ]
            },
            analysis: {
                name: 'Analysis Components',
                components: [
                    'MarketSentimentAnalyzer',
                    'NexusGuardAdvancedIndicators',
                    'NexusGuardMathematicalAnalysis',
                    'NexusGuardRiskModel'
                ]
            }
        }
    },
    visualization: {
        name: 'Visualization System',
        components: {
            core: {
                name: 'Visualization Core',
                components: [
                    'VisualizationManager',
                    'NexusGuardVisualization',
                    'NexusGuardAdvancedCharting'
                ]
            },
            advanced: {
                name: 'Advanced Features',
                components: [
                    'AdvancedVisualizationBase',
                    'MarketDepthVisualizations',
                    'AnalyticalVisualizationEngine'
                ]
            },
            formatters: {
                name: 'Chart Formatters',
                components: [
                    'AmChartsFormatter',
                    'ApexChartsFormatter',
                    'EChartsFormatter',
                    'HighchartsFormatter',
                    'PlotlyFormatter'
                ]
            }
        }
    }
};

const sprintStructure = {
    current: {
        name: 'Sprint 1: Core Security Implementation',
        startDate: '2024-02-01',
        endDate: '2024-02-15',
        status: 'in-progress',
        tasks: {
            backlog: [
                {
                    id: 'SEC-1',
                    title: 'SecurityManager Implementation',
                    description: 'Implement core security manager with validator integration',
                    priority: 'critical',
                    assignee: 'Security Team',
                    dependencies: [],
                    subtasks: [
                        'Setup security roles',
                        'Implement validation flow',
                        'Add emergency handlers'
                    ]
                },
                // Add more backlog items
            ],
            inProgress: [
                {
                    id: 'SYNC-1',
                    title: 'State Synchronization',
                    description: 'Implement validator state synchronization',
                    priority: 'high',
                    assignee: 'Core Team',
                    dependencies: ['SEC-1']
                },
                // Add more in-progress items
            ],
            review: [
                {
                    id: 'VAL-1',
                    title: 'Validation Framework',
                    description: 'Setup base validation framework',
                    priority: 'high',
                    assignee: 'Validation Team',
                    status: 'in-review'
                },
                // Add more review items
            ],
            done: [
                {
                    id: 'INIT-1',
                    title: 'Project Setup',
                    description: 'Initialize project structure and base contracts',
                    priority: 'high',
                    assignee: 'Core Team',
                    status: 'completed'
                },
                // Add more completed items
            ]
        }
    }
};

// Function to render component tree
function renderComponentTree() {
    const componentContainer = document.getElementById('components');
    Object.keys(componentStructure).forEach(category => {
        const categoryData = componentStructure[category];
        const categoryElement = createCategoryElement(categoryData);
        componentContainer.appendChild(categoryElement);
    });
}

// Function to render sprint board
function renderSprintBoard() {
    const sprintBoard = document.querySelector('.sprint-board');
    Object.keys(sprintStructure.current.tasks).forEach(column => {
        const columnElement = createSprintColumn(column, sprintStructure.current.tasks[column]);
        sprintBoard.appendChild(columnElement);
    });
}

// Function to create category element
function createCategoryElement(categoryData) {
    const categoryDiv = document.createElement('div');
    categoryDiv.className = 'col-md-6 mb-4';
    categoryDiv.innerHTML = `
        <div class="module-card ${categoryData.name.toLowerCase()}-component">
            <h3>${categoryData.name}</h3>
            <div class="component-list">
                ${renderComponents(categoryData.components)}
            </div>
        </div>
    `;
    return categoryDiv;
}

// Function to render components
function renderComponents(components) {
    return Object.keys(components).map(key => {
        const component = components[key];
        return `
            <div class="component-item">
                <strong>${component.name}</strong>
                ${component.subcomponents ? 
                    `<ul>${component.subcomponents.map(sub => 
                        `<li>${sub}</li>`).join('')}</ul>` : ''}
            </div>
        `;
    }).join('');
}

// Initialize dashboard
document.addEventListener('DOMContentLoaded', function() {
    renderComponentTree();
    renderSprintBoard();
});

        // Sprint data structure
        const sprintTasks = {
            // Sprint task definitions will go here
        };

        // Initialize dashboard
        document.addEventListener('DOMContentLoaded', function() {
            // Dashboard initialization code will go here
        });

        const mermaidConfig = {
    graph: `
    graph TB
        %% Core Protocol Hub
        NexusCore[NexusGuard DeFi Protocol V1]
        
        %% Main Hubs
        NexusCore --> SecurityHub[Security Manager]
        NexusCore --> AnalyticsHub[Analytics Engine]
        NexusCore --> VisualizationHub[Visualization System]
        NexusCore --> Registry[Protocol Registry]
        
        %% Security Components
        subgraph Security Management
            SecurityHub --> |Core Security|SecurityCore[Core Security]
            SecurityHub --> |Validation|SecurityValidation[Validation System]
            SecurityHub --> |Monitoring|SecurityMonitoring[Security Monitoring]
            
            %% Core Security Components
            SecurityCore --> AccessControl
            SecurityCore --> BlocklistManager
            SecurityCore --> EmergencySystem
            SecurityCore --> FraudDetection
            SecurityCore --> IntrusionDetection
            SecurityCore --> RateLimiter
            SecurityCore --> SecurityAudit
            SecurityCore --> SecurityUpdates
            
            %% Validation Components
            SecurityValidation --> BaseValidator
            SecurityValidation --> ComponentValidator
            SecurityValidation --> TransactionValidator
            SecurityValidation --> SecurityBenchmark
            
            %% Monitoring Components
            SecurityMonitoring --> SecurityMonitor
            SecurityMonitoring --> SecurityMetrics
            SecurityMonitoring --> SecurityPatterns
        end
        
        %% Analytics System
        subgraph Analytics System
            AnalyticsHub --> MarketAnalysis[Market Analysis]
            AnalyticsHub --> RiskAnalysis[Risk Analysis]
            AnalyticsHub --> DataProcessing[Data Processing]
            
            %% Market Analysis
            MarketAnalysis --> MarketSentiment[Market Sentiment Analyzer]
            MarketAnalysis --> AdvancedIndicators[Advanced Indicators]
            
            %% Risk Analysis
            RiskAnalysis --> RiskModel[Risk Model]
            RiskAnalysis --> MathAnalysis[Mathematical Analysis]
            
            %% Data Processing
            DataProcessing --> DataAggregator
            DataProcessing --> ReportGenerator
        end
        
        %% Visualization System
        subgraph Visualization
            VisualizationHub --> ChartSystem[Charting System]
            VisualizationHub --> DataViz[Data Visualization]
            VisualizationHub --> RealTime[Real-Time Processing]
            
            %% Charting Components
            ChartSystem --> AdvancedCharting
            ChartSystem --> ChartFormatters[Chart Formatters]
            
            %% Data Visualization
            DataViz --> MarketDepth[Market Depth]
            DataViz --> TechnicalAnalysis[Technical Analysis]
            
            %% Real-Time Components
            RealTime --> RealTimeHandler
            RealTime --> CacheSystem[Cache System]
        end
        
        %% Registry System
        subgraph Registry System
            Registry --> ComponentRegistry
            Registry --> ValidationRegistry
            Registry --> StorageRegistry
        end
        
        %% Cross-Chain Components
        subgraph Cross-Chain
            CrossChainManager --> Bridge[NexusGuard Bridge]
            CrossChainManager --> Verifier[Cross-Chain Verifier]
        end
        
        %% Optimization System
        subgraph System Optimization
            CacheManager --> AdvancedCache
            CacheManager --> GasOptimizer
            CacheManager --> BatchProcessor
        end
    `,

    // Mermaid configuration options
    config: {
        theme: 'default',
        themeVariables: {
            primaryColor: '#00bcd4',
            primaryTextColor: '#fff',
            primaryBorderColor: '#009db1',
            lineColor: '#009db1',
            secondaryColor: '#ff9800',
            tertiaryColor: '#4caf50'
        },
        flowchart: {
            curve: 'basis',
            padding: 15
        }
    }
};

// Metrics Implementation
const metricsSystem = {
    categories: {
        security: {
            name: 'Security Metrics',
            metrics: [
                {
                    name: 'Security Score',
                    value: 94,
                    trend: 'up',
                    color: 'success',
                    icon: 'shield-alt'
                },
                {
                    name: 'Vulnerabilities',
                    value: 0,
                    trend: 'stable',
                    color: 'success',
                    icon: 'bug'
                },
                {
                    name: 'Audit Status',
                    value: 88,
                    trend: 'up',
                    color: 'info',
                    icon: 'check-circle'
                }
            ]
        },
        performance: {
            name: 'Performance Metrics',
            metrics: [
                {
                    name: 'Gas Optimization',
                    value: 92,
                    trend: 'up',
                    color: 'success',
                    icon: 'gas-pump'
                },
                {
                    name: 'Response Time',
                    value: 95,
                    trend: 'up',
                    color: 'success',
                    icon: 'clock'
                },
                {
                    name: 'Cache Hit Rate',
                    value: 89,
                    trend: 'up',
                    color: 'info',
                    icon: 'database'
                }
            ]
        },
        development: {
            name: 'Development Progress',
            metrics: [
                {
                    name: 'Code Coverage',
                    value: 91,
                    trend: 'up',
                    color: 'success',
                    icon: 'code'
                },
                {
                    name: 'Sprint Progress',
                    value: 67,
                    trend: 'up',
                    color: 'warning',
                    icon: 'tasks'
                },
                {
                    name: 'Components Ready',
                    value: 78,
                    trend: 'up',
                    color: 'info',
                    icon: 'puzzle-piece'
                }
            ]
        }
    }
};

// Function to render metrics
function renderMetrics() {
    const metricsPanel = document.querySelector('.metrics-panel');
    Object.values(metricsSystem.categories).forEach(category => {
        category.metrics.forEach(metric => {
            const metricCard = createMetricCard(metric);
            metricsPanel.appendChild(metricCard);
        });
    });
}

// Function to create metric card
function createMetricCard(metric) {
    const card = document.createElement('div');
    card.className = 'metric-card';
    card.innerHTML = `
        <div class="metric-header">
            <i class="fas fa-${metric.icon} text-${metric.color}"></i>
            <h3>${metric.name}</h3>
        </div>
        <div class="metric-value">
            <h4>${metric.value}%</h4>
            <i class="fas fa-arrow-${metric.trend} text-${metric.color}"></i>
        </div>
        <div class="progress">
            <div class="progress-bar bg-${metric.color}" 
                 role="progressbar" 
                 style="width: ${metric.value}%" 
                 aria-valuenow="${metric.value}" 
                 aria-valuemin="0" 
                 aria-valuemax="100">
            </div>
        </div>
    `;
    return card;
}

// Initialize mermaid diagram
function initializeMermaid() {
    const diagramContainer = document.querySelector('.mermaid');
    diagramContainer.innerHTML = mermaidConfig.graph;
    mermaid.initialize(mermaidConfig.config);
}

// Update dashboard initialization
document.addEventListener('DOMContentLoaded', function() {
    renderComponentTree();
    renderSprintBoard();
    renderMetrics();
    initializeMermaid();
    
    // Initialize tooltips and popovers
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });
});

        class SprintBoardManager {
    constructor() {
        this.draggedItem = null;
        this.sprintColumns = ['backlog', 'inProgress', 'review', 'done'];
        this.statusMapping = {
            backlog: 'Pending',
            inProgress: 'In Progress',
            review: 'Under Review',
            done: 'Completed'
        };
        this.taskStatusHistory = new Map();
        this.initializeDragAndDrop();
    }

    initializeDragAndDrop() {
        document.addEventListener('dragstart', (e) => {
            if (e.target.classList.contains('task-card')) {
                this.draggedItem = e.target;
                e.target.classList.add('dragging');
            }
        });

        document.addEventListener('dragend', (e) => {
            if (e.target.classList.contains('task-card')) {
                e.target.classList.remove('dragging');
            }
        });

        this.sprintColumns.forEach(columnId => {
            const column = document.getElementById(columnId);
            if (column) {
                column.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = this.getDragAfterElement(column, e.clientY);
                    const draggable = this.draggedItem;
                    if (afterElement == null) {
                        column.appendChild(draggable);
                    } else {
                        column.insertBefore(draggable, afterElement);
                    }
                });
            }
        });
    }

    getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.task-card:not(.dragging)')];
        
        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - box.top - box.height / 2;
            if (offset < 0 && offset > closest.offset) {
                return { offset: offset, element: child };
            } else {
                return closest;
            }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    createTaskCard(task) {
        const card = document.createElement('div');
        card.className = `task-card priority-${task.priority}`;
        card.draggable = true;
        card.id = `task-${task.id}`;
        card.innerHTML = `
            <div class="task-header">
                <span class="task-id">${task.id}</span>
                <span class="badge bg-${this.getPriorityColor(task.priority)}">${task.priority}</span>
            </div>
            <h5 class="task-title">${task.title}</h5>
            <p class="task-description">${task.description}</p>
            <div class="task-footer">
                <span class="assignee"><i class="fas fa-user"></i> ${task.assignee}</span>
                <span class="task-metrics">
                    <i class="fas fa-clock"></i> ${this.getTimeSpent(task.id)}
                    <i class="fas fa-code-branch"></i> ${task.dependencies.length}
                </span>
            </div>
            <div class="task-progress">
                <div class="progress">
                    <div class="progress-bar bg-${this.getPriorityColor(task.priority)}" 
                         style="width: ${this.calculateProgress(task)}%"></div>
                </div>
            </div>
        `;
        
        this.attachTaskEventListeners(card, task);
        return card;
    }

    getPriorityColor(priority) {
        const colors = {
            critical: 'danger',
            high: 'warning',
            medium: 'info',
            low: 'success'
        };
        return colors[priority] || 'secondary';
    }

    calculateProgress(task) {
        if (task.subtasks && task.subtasks.length > 0) {
            const completed = task.subtasks.filter(subtask => subtask.completed).length;
            return (completed / task.subtasks.length) * 100;
        }
        return task.progress || 0;
    }

    getTimeSpent(taskId) {
        const history = this.taskStatusHistory.get(taskId);
        if (!history) return '0d';
        const start = history[0].timestamp;
        const now = Date.now();
        const days = Math.floor((now - start) / (1000 * 60 * 60 * 24));
        return `${days}d`;
    }

    attachTaskEventListeners(card, task) {
        card.addEventListener('click', () => this.openTaskDetails(task));
        card.addEventListener('dragstart', () => this.updateTaskStatus(task.id, 'moving'));
        card.addEventListener('dragend', (e) => this.handleTaskDrop(e, task));
    }

    openTaskDetails(task) {
        // Create and show task details modal
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = `taskModal-${task.id}`;
        modal.innerHTML = `
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">${task.title} (${task.id})</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <div class="task-details">
                            <div class="row">
                                <div class="col-md-8">
                                    <h6>Description</h6>
                                    <p>${task.description}</p>
                                    
                                    <h6>Subtasks</h6>
                                    <ul class="subtasks-list">
                                        ${this.renderSubtasks(task)}
                                    </ul>
                                </div>
                                <div class="col-md-4">
                                    <div class="task-metadata">
                                        <p><strong>Status:</strong> ${this.getTaskStatus(task.id)}</p>
                                        <p><strong>Priority:</strong> ${task.priority}</p>
                                        <p><strong>Assignee:</strong> ${task.assignee}</p>
                                        <p><strong>Created:</strong> ${this.formatDate(task.created)}</p>
                                        <p><strong>Dependencies:</strong></p>
                                        <ul>
                                            ${this.renderDependencies(task)}
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        new bootstrap.Modal(modal).show();
    }

    renderSubtasks(task) {
        if (!task.subtasks) return '';
        return task.subtasks.map(subtask => `
            <li class="subtask-item">
                <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
                       onchange="sprintBoard.updateSubtask('${task.id}', '${subtask.id}')">
                <span>${subtask}</span>
            </li>
        `).join('');
    }

    renderDependencies(task) {
        if (!task.dependencies || task.dependencies.length === 0) {
            return '<li>No dependencies</li>';
        }
        return task.dependencies.map(dep => `
            <li>${dep}</li>
        `).join('');
    }

    formatDate(date) {
        return new Date(date).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric'
        });
    }

    updateTaskStatus(taskId, newStatus) {
        const history = this.taskStatusHistory.get(taskId) || [];
        history.push({
            status: newStatus,
            timestamp: Date.now()
        });
        this.taskStatusHistory.set(taskId, history);
        this.emitTaskUpdate(taskId, newStatus);
    }

    emitTaskUpdate(taskId, status) {
        const event = new CustomEvent('taskUpdate', {
            detail: { taskId, status }
        });
        document.dispatchEvent(event);
    }
}

// Initialize Sprint Board
const sprintBoard = new SprintBoardManager();

// Status Tracking System
class StatusTrackingSystem {
    constructor() {
        this.statusUpdates = new Map();
        this.initializeListeners();
    }

    initializeListeners() {
        document.addEventListener('taskUpdate', (e) => {
            this.recordStatusUpdate(e.detail);
            this.updateMetrics();
        });
    }

    recordStatusUpdate(update) {
        const { taskId, status } = update;
        const updates = this.statusUpdates.get(taskId) || [];
        updates.push({
            status,
            timestamp: Date.now()
        });
        this.statusUpdates.set(taskId, updates);
    }

    updateMetrics() {
        const metrics = this.calculateMetrics();
        this.updateDashboardMetrics(metrics);
    }

    calculateMetrics() {
        // Calculate various metrics based on status updates
        const metrics = {
            completionRate: this.calculateCompletionRate(),
            averageCycleTime: this.calculateAverageCycleTime(),
            blockerCount: this.calculateBlockerCount()
        };
        return metrics;
    }

    // Add these to the existing StatusTrackingSystem class
    calculateCompletionRate() {
        const totalTasks = this.statusUpdates.size;
        const completedTasks = Array.from(this.statusUpdates.values())
            .filter(updates => updates[updates.length - 1].status === 'done').length;
        return totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
    }

    calculateAverageCycleTime() {
        const cycleTimes = [];
        this.statusUpdates.forEach(updates => {
            if (updates.length >= 2) {
                const start = updates[0].timestamp;
                const end = updates[updates.length - 1].timestamp;
                cycleTimes.push(end - start);
            }
        });
        return cycleTimes.length > 0 ? 
            cycleTimes.reduce((a, b) => a + b, 0) / cycleTimes.length / (1000 * 60 * 60 * 24) : 0;
    }

    calculateBlockerCount() {
        return Array.from(this.statusUpdates.values())
            .filter(updates => updates[updates.length - 1].status === 'blocked').length;
    }

    updateDashboardMetrics(metrics) {
        // Update the dashboard with new metrics
        document.querySelectorAll('.metric-card').forEach(card => {
            const metricName = card.querySelector('h3').textContent;
            switch(metricName) {
                case 'Completion Rate':
                    this.updateMetricCard(card, metrics.completionRate);
                    break;
                case 'Average Cycle Time':
                    this.updateMetricCard(card, metrics.averageCycleTime);
                    break;
                case 'Active Blockers':
                    this.updateMetricCard(card, metrics.blockerCount);
                    break;
            }
        });
    }

    updateMetricCard(card, value) {
        const valueElement = card.querySelector('.metric-value h4');
        const progressBar = card.querySelector('.progress-bar');
        
        if (valueElement && progressBar) {
            valueElement.textContent = typeof value === 'number' ? 
                value.toFixed(1) + '%' : value;
            progressBar.style.width = `${value}%`;
        }
    }
}

// Initialize Status Tracking
const statusTracker = new StatusTrackingSystem();

        // Component Dependency Visualization System
class ComponentDependencyVisualizer {
    constructor() {
        this.dependencies = new Map();
        this.graph = {
            nodes: new Set(),
            edges: new Set()
        };
        this.colors = {
            security: '#ff4757',
            analytics: '#2ed573',
            core: '#1e90ff',
            visualization: '#ffa502'
        };
    }

    initializeGraph() {
        // Parse component structure and build dependency graph
        Object.entries(componentStructure).forEach(([category, data]) => {
            this.processCategory(category, data);
        });

        // Create visualization using D3.js
        this.createForceDirectedGraph();
    }

    processCategory(category, data) {
        const components = this.flattenComponents(data.components);
        components.forEach(component => {
            this.graph.nodes.add({
                id: component.name,
                category: category,
                color: this.colors[category] || '#747d8c'
            });

            if (component.dependencies) {
                component.dependencies.forEach(dep => {
                    this.graph.edges.add({
                        source: component.name,
                        target: dep,
                        value: 1
                    });
                });
            }
        });
    }

    flattenComponents(components, result = []) {
        Object.values(components).forEach(component => {
            result.push(component);
            if (component.components) {
                this.flattenComponents(component.components, result);
            }
        });
        return result;
    }

    createForceDirectedGraph() {
        const width = document.querySelector('.dependency-chart').clientWidth;
        const height = 800;

        const svg = d3.select('.dependency-chart')
            .append('svg')
            .attr('width', width)
            .attr('height', height);

        const simulation = d3.forceSimulation(Array.from(this.graph.nodes))
            .force('link', d3.forceLink(Array.from(this.graph.edges))
                .id(d => d.id)
                .distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(70));

        // Create arrow markers
        svg.append('defs').selectAll('marker')
            .data(['end'])
            .enter().append('marker')
            .attr('id', 'arrow')
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 20)
            .attr('refY', 0)
            .attr('markerWidth', 6)
            .attr('markerHeight', 6)
            .attr('orient', 'auto')
            .append('path')
            .attr('d', 'M0,-5L10,0L0,5')
            .attr('fill', '#666');

        // Draw links
        const link = svg.append('g')
            .selectAll('line')
            .data(Array.from(this.graph.edges))
            .enter().append('line')
            .attr('stroke', '#666')
            .attr('stroke-width', 1.5)
            .attr('marker-end', 'url(#arrow)');

        // Create nodes
        const node = svg.append('g')
            .selectAll('.node')
            .data(Array.from(this.graph.nodes))
            .enter().append('g')
            .attr('class', 'node')
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Add circles to nodes
        node.append('circle')
            .attr('r', 30)
            .attr('fill', d => d.color)
            .attr('stroke', '#fff')
            .attr('stroke-width', 2);

        // Add labels to nodes
        node.append('text')
            .text(d => d.id)
            .attr('text-anchor', 'middle')
            .attr('dy', '.35em')
            .attr('fill', '#fff')
            .style('font-size', '12px');

        // Update positions on simulation tick
        simulation.on('tick', () => {
            link
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            node
                .attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // Drag functions
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    }
}

// Real-time Update System
class RealTimeUpdateSystem {
    constructor() {
        this.updateInterval = 5000; // 5 seconds
        this.subscribers = new Map();
        this.websocket = null;
        this.initializeWebSocket();
    }

    initializeWebSocket() {
        this.websocket = new WebSocket('wss://your-websocket-server');
        
        this.websocket.onopen = () => {
            console.log('WebSocket connection established');
            this.startPeriodicUpdates();
        };

        this.websocket.onmessage = (event) => {
            const update = JSON.parse(event.data);
            this.handleUpdate(update);
        };

        this.websocket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.fallbackToPolling();
        };
    }

    startPeriodicUpdates() {
        setInterval(() => {
            this.requestUpdates();
        }, this.updateInterval);
    }

    requestUpdates() {
        if (this.websocket && this.websocket.readyState === WebSocket.OPEN) {
            this.websocket.send(JSON.stringify({
                type: 'request_updates',
                components: Array.from(this.subscribers.keys())
            }));
        }
    }

    handleUpdate(update) {
        const { type, data } = update;
        
        switch (type) {
            case 'task_update':
                this.updateTaskStatus(data);
                break;
            case 'component_update':
                this.updateComponentStatus(data);
                break;
            case 'metrics_update':
                this.updateMetrics(data);
                break;
            case 'security_alert':
                this.handleSecurityAlert(data);
                break;
        }

        // Notify subscribers
        if (this.subscribers.has(type)) {
            this.subscribers.get(type).forEach(callback => callback(data));
        }
    }

    subscribe(type, callback) {
        if (!this.subscribers.has(type)) {
            this.subscribers.set(type, new Set());
        }
        this.subscribers.get(type).add(callback);
    }

    unsubscribe(type, callback) {
        if (this.subscribers.has(type)) {
            this.subscribers.get(type).delete(callback);
        }
    }

    updateTaskStatus(data) {
        const { taskId, status, progress } = data;
        const taskElement = document.querySelector(`#task-${taskId}`);
        if (taskElement) {
            taskElement.querySelector('.progress-bar').style.width = `${progress}%`;
            taskElement.setAttribute('data-status', status);
        }
    }

    updateComponentStatus(data) {
        const { componentId, status, metrics } = data;
        const componentElement = document.querySelector(`#component-${componentId}`);
        if (componentElement) {
            componentElement.querySelector('.status-indicator').className = 
                `status-indicator ${status.toLowerCase()}`;
            
            // Update component metrics
            Object.entries(metrics).forEach(([key, value]) => {
                const metricElement = componentElement.querySelector(`[data-metric="${key}"]`);
                if (metricElement) {
                    metricElement.textContent = value;
                }
            });
        }
    }

    updateMetrics(data) {
        Object.entries(data).forEach(([metricId, value]) => {
            const metricCard = document.querySelector(`#metric-${metricId}`);
            if (metricCard) {
                metricCard.querySelector('.metric-value').textContent = value;
                metricCard.querySelector('.progress-bar').style.width = `${value}%`;
            }
        });
    }

    handleSecurityAlert(data) {
        const { level, message, componentId } = data;
        const alertElement = document.createElement('div');
        alertElement.className = `alert alert-${level} alert-dismissible fade show`;
        alertElement.innerHTML = `
            <strong>Security Alert:</strong> ${message}
            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
        `;
        document.querySelector('.alerts-container').appendChild(alertElement);

        // Highlight affected component
        const componentElement = document.querySelector(`#component-${componentId}`);
        if (componentElement) {
            componentElement.classList.add('security-alert');
            setTimeout(() => {
                componentElement.classList.remove('security-alert');
            }, 5000);
        }
    }

    fallbackToPolling() {
        console.log('Falling back to polling updates');
        this.startPolling();
    }

    startPolling() {
        setInterval(() => {
            fetch('/api/updates')
                .then(response => response.json())
                .then(updates => {
                    updates.forEach(update => this.handleUpdate(update));
                })
                .catch(error => console.error('Polling error:', error));
        }, this.updateInterval);
    }
}

// Initialize systems
const dependencyVisualizer = new ComponentDependencyVisualizer();
const realTimeUpdates = new RealTimeUpdateSystem();

// Initialize when document is ready
document.addEventListener('DOMContentLoaded', () => {
    dependencyVisualizer.initializeGraph();
    
    // Subscribe to updates
    realTimeUpdates.subscribe('task_update', (data) => {
        sprintBoard.handleTaskUpdate(data);
    });
    
    realTimeUpdates.subscribe('security_alert', (data) => {
        statusTracker.handleSecurityAlert(data);
    });
});

    </script>
</body>
</html>
